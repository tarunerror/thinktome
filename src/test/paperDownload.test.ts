import { describe, it, expect } from 'vitest';

describe('Paper Download Functionality', () => {
  it('should create properly formatted markdown content', () => {
    const mockPaperSections: Record<string, string> = {
      'abstract': '# Abstract\n\nThis is the abstract section with **bold** and *italic* text.',
      'introduction': '# Introduction\n\nThis is the introduction with:\n* Point 1\n* Point 2\n\nAnd a paragraph.',
      'methodology': '# Methodology\n\n## Research Design\n\nDescription of the research design.',
      'results': '# Results\n\nThe results show significant findings.',
      'conclusion': '# Conclusion\n\nIn conclusion, this research demonstrates...'
    };

    const topic = 'Test Research Paper';
    const currentDate = new Date().toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });

    // Define the proper order of sections (same as in PaperContent component)
    const sectionOrder = [
      'abstract', 'introduction', 'literature-review', 'research-background',
      'problem-statement', 'research-objectives', 'theoretical-framework',
      'methodology', 'research-design', 'materials-equipment', 'procedures',
      'experimental-design', 'data-collection', 'analysis-methods', 'results',
      'data-analysis', 'findings', 'discussion', 'implications', 'limitations',
      'future-work', 'conclusion', 'references', 'appendices'
    ];

    // Create markdown content (same logic as in handleDownload)
    let markdownContent = `# ${topic}\n\n`;
    markdownContent += `*Generated by ThinkTome AI - ${currentDate}*\n\n`;
    markdownContent += `---\n\n`;

    sectionOrder.forEach(sectionId => {
      if (mockPaperSections[sectionId] && mockPaperSections[sectionId].trim()) {
        const sectionContent = mockPaperSections[sectionId].trim();
        
        if (!sectionContent.startsWith('#')) {
          const sectionTitle = sectionId
            .split('-')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
            .join(' ');
          markdownContent += `## ${sectionTitle}\n\n`;
        }
        
        markdownContent += `${sectionContent}\n\n`;
      }
    });

    markdownContent += `---\n\n`;
    markdownContent += `*This research paper was generated using ThinkTome's AI-powered research assistant.*\n`;
    markdownContent += `*For more information, visit: https://thinktome.netlify.app*\n`;

    // Verify the content structure
    expect(markdownContent).toContain(`# ${topic}`);
    expect(markdownContent).toContain('Generated by ThinkTome AI');
    expect(markdownContent).toContain('# Abstract');
    expect(markdownContent).toContain('# Introduction');
    expect(markdownContent).toContain('# Methodology');
    expect(markdownContent).toContain('# Results');
    expect(markdownContent).toContain('# Conclusion');
    expect(markdownContent).toContain('**bold**');
    expect(markdownContent).toContain('*italic*');
    expect(markdownContent).toContain('* Point 1');
    expect(markdownContent).toContain('* Point 2');
    expect(markdownContent).toContain('## Research Design');
  });

  it('should handle empty sections gracefully', () => {
    const mockPaperSections: Record<string, string> = {
      'abstract': 'This is just the abstract.',
      'introduction': '', // Empty section
      'methodology': '   ', // Whitespace only
      'results': 'Some results here.'
    };

    const topic = 'Test Paper';
    const sectionOrder = ['abstract', 'introduction', 'methodology', 'results', 'conclusion'];
    
    let markdownContent = `# ${topic}\n\n`;
    
    sectionOrder.forEach(sectionId => {
      if (mockPaperSections[sectionId] && mockPaperSections[sectionId].trim()) {
        const sectionContent = mockPaperSections[sectionId].trim();
        const sectionTitle = sectionId
          .split('-')
          .map(word => word.charAt(0).toUpperCase() + word.slice(1))
          .join(' ');
        markdownContent += `## ${sectionTitle}\n\n`;
        markdownContent += `${sectionContent}\n\n`;
      }
    });

    // Should only contain non-empty sections
    expect(markdownContent).toContain('## Abstract');
    expect(markdownContent).toContain('## Results');
    expect(markdownContent).not.toContain('## Introduction');
    expect(markdownContent).not.toContain('## Methodology');
  });

  it('should handle DOCX text parsing correctly', () => {
    const parseInlineFormatting = (text: string) => {
      const parts = text.split(/(\*\*.*?\*\*|\*.*?\*|`.*?`)/);
      const results: { text: string; bold?: boolean; italics?: boolean; font?: string }[] = [];
      
      parts.forEach(part => {
        if (part.startsWith('**') && part.endsWith('**')) {
          results.push({ text: part.slice(2, -2), bold: true });
        } else if (part.startsWith('*') && part.endsWith('*') && !part.startsWith('**')) {
          results.push({ text: part.slice(1, -1), italics: true });
        } else if (part.startsWith('`') && part.endsWith('`')) {
          results.push({ text: part.slice(1, -1), font: 'Courier New' });
        } else if (part.trim()) {
          results.push({ text: part });
        }
      });
      
      return results.length > 0 ? results : [{ text: text }];
    };

    // Test bold text
    const boldResult = parseInlineFormatting('This is **bold** text');
    expect(boldResult).toHaveLength(3);
    expect(boldResult[0].text).toBe('This is ');
    expect(boldResult[1].text).toBe('bold');
    expect(boldResult[1].bold).toBe(true);
    expect(boldResult[2].text).toBe(' text');

    // Test italic text
    const italicResult = parseInlineFormatting('This is *italic* text');
    expect(italicResult).toHaveLength(3);
    expect(italicResult[1].text).toBe('italic');
    expect(italicResult[1].italics).toBe(true);

    // Test code text
    const codeResult = parseInlineFormatting('This is `code` text');
    expect(codeResult).toHaveLength(3);
    expect(codeResult[1].text).toBe('code');
    expect(codeResult[1].font).toBe('Courier New');

    // Test mixed formatting
    const mixedResult = parseInlineFormatting('**Bold** and *italic* and `code`');
    expect(mixedResult).toHaveLength(5);
    expect(mixedResult[0].bold).toBe(true);
    expect(mixedResult[2].italics).toBe(true);
    expect(mixedResult[4].font).toBe('Courier New');
  });
});